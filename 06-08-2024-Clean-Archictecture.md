#### Layered Architecture

A standard way to architecture application is the layered architecture. Where we typically have four layers : Infrastructure {'<'}- Domain {'<'}- Business {'<'}- Presentation with the dependency following inwards and there is a close coupling between the levels

#### Clean Architecture

Clean Architecture flips the dependency via dependency injection/inversion such that the outer layers (e.g. API/Infrastructure) depends on abstractions defined by inner core layers (e.g. Application/Domain). This makes it easy if we were to change infrastructure as it will not have as much of an impact on the core business layers

Creating the folders for a sample clean architecture .Net Core project :

```shell
mkdir Core
cd Core
mkdir Domain
mkdir Application
cd ../
mkdir Infrastructure
cd Infrastructure
mkdir Persistence
cd ../
mkdir API
```

This results in a folder structure like this :
- Core
	- Application
	- Domain
- Infrastructure
	- Persistence
- API

First we create a solution to house the project :

```shell
dotnet new sln
```

We then create the Domain Class Library which will house the Entities for the project :

```shell
cd Core
dotnet new classlib -n Domain
cd ../
```

Next we create the Application Class Library which will house the Business Logic and Contracts for the Infrastructure Layer :

```shell
cd Core
dotnet new classlib -n Application
```

We then add a Project Reference of the Domain Class Library to the Application Class Library

```shell
cd Application
dotnet add reference ../Domain
cd ../..
```

Next we create the Persistence Class Library which will house the Entity Framework Core DbContext :

```shell
cd Infrastructure
dotnet new classlib -n Persistence
```

We then add the Microsoft.EntityFrameworkCore and Microsoft.EntityFrameworkCore.SqlServer packages from Nuget to Persistence as well as the Project Reference of Application Class Library :

```shell
cd Persistence
dotnet add package Microsoft.EntityFrameworkCore
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add reference ../../Core/Application 
cd ../..
```

Next we create the API as a WebAPI and add both Application and Infrastructure :

```shell
dotnet new webapi -n API
cd API
dotnet add reference ../Core/Application
dotnet add reference ../Infrastructure/Persistence
cd ..
```

We then add all the Projects to the Solution :
```shell
dotnet sln add Core/Domain
dotnet sln add Core/Application
dotnet sln add Infrastructure/Persistence
dotnet sln add API
```

The final resultant solution structure and project type is the following :
- Core
	- Application (Class Library)
	- Domain (Class Library)
- Infrastructure
	- Persistence (Class Library)
- API (Web API)

The Domain Project will hold all the Entities and Specifications objects.
The Application Project is where the Contracts will be defined and Business Logic should reside.
The Persistence Project will be where most Contracts are implemented and where Infrastructural libraries like Entity Framework Core will be implemented.
Lastly, the API Project will be where we expose the endpoints.

Next, we will have to clear up the autogenerated files :
```
rm "Core\Application\Class1.cs"
rm "Core\Domain\Class1.cs" 
rm "Infrastructure\Persistence\Class1.cs"
```

We then have to add in Service Extensions for Dependency Inversion.

Notice that so far we have added Project References from (Application -{'>'} Domain), (Persistence -{'>'} Application) and (API -{'>'} Application & Persistence).

(Note that according to Clean Architecture Presentation/API layer should not have dependency on the Infrastructure/Persistence layer, this reference is added just so that we have call the Service Extensions methods for the Infrastructure layer)

The confusion arising from Clean Architecture is usually that unlike the layered architecture where the Infrastructural Layer is coupled with the Domain Layer and the Controller Layer has a reference to it, for Clean Architecture our Application layer does not have a reference to the Infrastructure layer e.g. EF Core. How then can the Application layer access the database and perform business actions on the entities? We will have to rely on dependency inversion and injection where we will just define interfaces and the actual implementation will be injected during compile time.

Let us create the Service Registration files :
```shell
touch "Core/Application/ApplicationServiceRegistration.cs"
touch "Infrastructure/Persistence/PersistenceServiceRegistration.cs"
```

ApplicationServiceRegistration.cs will be where we will register Application related service dependencies such as AutoMapper and MediatR.

First we will add the AutoMapper and MediatR dependencies and register them:
```shell
cd Core/Application
dotnet add package AutoMapper
dotnet add package MediatR
```

```csharp
using System.Reflection;
using Microsoft.Extensions.DependencyInjection;
  
namespace Application;

public static class ApplicationServiceRegistration
{
    public static IServiceCollection AddApplicationServices(this IServiceCollection services)
    {
        services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly()));
        services.AddAutoMapper(Assembly.GetExecutingAssembly());

        return services;
    }
}
```

PersistenceServiceRegistration.cs will be where we will register Persistence Infrastructure related service dependencies such as EF Core DB Context and Repository implementations.

We already added the Entity Framework Core dependencies earlier so we just have to create the Entities, DB Context and register them.

We will first be creating our Entities for a Code-First approach to generate out the Database Schemas (Sample Entities referred here for a Sample Entity Attribute Value (Anti-Pattern but only used for small project) Proof of Concept)) :
```shell
cd ..
mkdir Domain/Entities
touch "Domain/Entities/EAVEntity.cs"
touch "Domain/Entities/EAVAttribute.cs"
touch "Domain/Entities/EAVValue.cs"
```

```csharp
using System.ComponentModel.DataAnnotations;

namespace Domain;

public class EAVEntity // Parent Entity mapped to a user defined table
{
    [Key]
    public long Id { get; set; } // Primary Key for the Entity
    public string Name { get; set;} = string.Empty;
    public string Description { get; set;} = string.Empty;
    // Optional Collection Navigation to reference dependent entities
    public ICollection<EAVAttribute> EAVAttributes { get; set; } = new List<EAVAttribute>();
}
```

```csharp
using System.ComponentModel.DataAnnotations;

namespace Domain;

public class EAVAttribute // Attribute Entity mapped to user defined columns
{
    [Key]
    public long Id { get; set; }
    public string AttributeName { get; set; } = string.Empty;
    public long EAVEntityId { get; set; } // Required foreign key property
    public EAVEntity EAVEntity { get; set; } = null!; // Required reference navigation to parent entity
    public ICollection<EAVValue> EAVValues{ get; set; } = new List<EAVValue>();
}
```

```csharp
using System.ComponentModel.DataAnnotations;

namespace Domain;

public class EAVValue
{
    [Key]
    public long Id { get; set; }
    public string Value { get; set; } = string.Empty;
    public long EAVAttributeId { get; set; }
    public EAVAttribute EAVAttribute { get; set; } = null!;
}
```

```shell
cd ..
mkdir Infrastructure/Persistence/Context
touch "Infrastructure/Persistence/Context/ApplicationDbContext.cs"
mkdir Infrastructure/Persistence/Repositories
touch "Infrastructure/Persistence/Repositories/BaseRepository.cs"

mkdir Core/Application/Contracts
mkdir Core/Application/Contracts/Persistence
touch "Core/Application/Contracts/Persistence/IRepository.cs"
```

```shell
using Domain;
using Microsoft.EntityFrameworkCore;

namespace Infrastructure.Persistence;

public class ApplicationDbContext: DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : base(options) { }
  
    public DbSet<EAVEntity> EAVEntities { get; set; }
    public DbSet<EAVAttribute> EAVAttributes { get; set; }
    public DbSet<EAVValue> EAVValues { get; set; }
}
```

```csharp
namespace Application.Contracts.Persistence;

public interface IRepository<T> where T : class
{
    Task<T> GetByIdAsync(long id);
    Task<IReadOnlyList<T>> ListAllAsync();
    Task<T> AddAsync(T entity);
    Task UpdateAsync(T entity);
    Task DeleteAsync(T entity);
}
```

```csharp
using Application.Contracts.Persistence;
using Microsoft.EntityFrameworkCore;

namespace Infrastructure.Persistence.Repositories;

public class BaseRepository<T> (ApplicationDbContext dbContext) : IRepository<T> where T : class
{
    private readonly ApplicationDbContext _dbContext = dbContext;
    public async Task<T> AddAsync(T entity)
    {
        await _dbContext.Set<T>().AddAsync(entity);
        await _dbContext.SaveChangesAsync();
        return entity;
    }

    public async Task DeleteAsync(T entity)
    {
        _dbContext.Remove(entity);
        await _dbContext.SaveChangesAsync();
    }

    public async Task<T> GetByIdAsync(long id)
    {
        return await _dbContext.Set<T>().FindAsync(id);
    }

    public async Task<IReadOnlyList<T>> ListAllAsync()
    {
        return await _dbContext.Set<T>().ToListAsync();
    }

    public async Task UpdateAsync(T entity)
    {
        _dbContext.Entry(entity).State = EntityState.Modified;
        await _dbContext.SaveChangesAsync();
    }
}
```

```csharp
using Application.Contracts.Persistence;
using Infrastructure.Persistence.Repositories;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace Infrastructure.Persistence;

public static class PersistenceServiceRegistration
{
    public static IServiceCollection AddPersistenceServices(this IServiceCollection services, IConfiguration configuration)
    {
        services.AddDbContext<ApplicationDbContext>(options =>       options.UseSqlServer(configuration.GetConnectionString("ApplicationConnectionString")));
        services.AddScoped(typeof(IRepository<>), typeof(BaseRepository<>));
 
        return services;
    }
}
```

Next we will update the Program.cs start up class in API layer to remove the default controllers and to add in the Service Registrations :
```csharp
using Infrastructure.Persistence;
using Application;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddApplicationServices();
builder.Services.AddPersistenceServices(builder.Configuration);

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

app.Run();
```

We also update the appsettings.json file to include the connection string :
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "ApplicationConnectionString": "Server=(localdb)\\MSSQLLocalDB;Database=HealthScreeningApplication;TrustServerCertificate=true;Trusted_Connection=True;"
  }
}
```
